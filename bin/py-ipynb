#!/bin/bash

# CONTAINER_ROOT: We treat the container as the root for this to work. Funny enough, this is the
# bottleneck of our script lol. Once I find a better way to do this (without hardcoding it), it will
# no longer be a bottleneck.
CONTAINER_ROOT=$(find  $HOME -type d -name "ECE-C147-Jupyter-Container" -print -quit)

# TARGET_DIR: Determines which HW directory to scan.
TARGET_DIR="$CONTAINER_ROOT/notebooks/$1"

# BASE_NAME: The file name (default is py_files).
BASE_NAME="${2:-"py_files"}"

# TARGET_NAME: What the file actually gets named. This is here to avoid overwriting.
TARGET_NAME="$BASE_NAME"

# TARGET_FILE: File with the .ipynb extension.
TARGET_FILE="$TARGET_DIR/$TARGET_NAME.ipynb"

cd "$TARGET_DIR" 2> /dev/null

# Invalid input || No path passed int => exit.
if [ $? -gt 0 ] || [ "$TARGET_DIR" = "$CONTAINER_ROOT/notebooks/" ]; then
    echo "$TARGET_DIR either does not exist or is not one of hw{1, 2, 3, 4, 5}."
    echo "Usage: ./py-ipynb [hw{1, 2, 3, 4, 5}] [target_name]"
    echo "Exiting..."
    exit 1
fi

# Read the files into an array.
readarray PY_FILES < <(find "$TARGET_DIR" -type f -name "*.py" -exec grep -l "YOUR CODE" {} +)

# Sanity check.
echo "Found ${#PY_FILES[@]} files:"
for PY_FILE in ${PY_FILES[@]}; do
    PY_FILE_NAME=$(basename $PY_FILE)
    echo "$PY_FILE_NAME"
done

# If we have nothing to do, exit.
if [ ${#PY_FILES[@]} -eq 0 ]; then
    echo "Exiting..."
    exit 0
fi


# If TARGET_FILE already exists, don't overwrite it. Instead, just append a -* to it, where * is the
# smallest number that doesn't cause a name conflict.
if test -f $TARGET_FILE; then
    read -p "$TARGET_FILE exists! would you like to overwrite it? [y/N] " yn

    counter=1
    while [[ -e "$TARGET_NAME.ipynb" ]]; do
        TARGET_NAME="${BASE_NAME}-${counter}"
        ((counter++))
    done

    TARGET_FILE="$TARGET_DIR/$TARGET_NAME.ipynb"

    # For fun
    case $yn in
        [Yy] ) echo "You might regret it. I also don't trust your judgement, so I moved the file to $TARGET_FILE instead";;
        [Nn] ) echo "Moving the file to $TARGET_FILE";;
    esac
fi

# If the template generator doesn't exist, make it.
if ! test -f "$CONTAINER_ROOT/ipynb-generator"; then
    $(cd "$CONTAINER_ROOT/bin/" && make)
fi

# Generate the template file. See ipynb-generator.c for details.
$CONTAINER_ROOT/bin/ipynb-generator "$TARGET_FILE" ${#PY_FILES[@]}

# Replace the placeholders in each block with the filename and file content.
for PY_FILE in ${PY_FILES[@]}; do
    PY_FILE_NAME=$(basename $PY_FILE)
    TMP_FILE=$(mktemp)

    # LORE: I spent north of 2 hours trying to figure out why my shit kept getting a NotJSON error
    # in Jupyter. the answer was because some of the python files used '\t' and those bitches were
    # invisible in the output. It also did not help that every JSON validator just said it was
    # invalid but wouldn't actually tell me where the error was. Yet another reason why python is
    # a garbage language.
    #
    # Note: The '/g' at the end of some commands is the global flag, which means that if there is
    # more than one occurrence within a line, then it will replace ALL occurrences.
    #
    # This sed command does several things. In order, we have
    # - 's/\t/     /g'    replaces all tab characters with 4 spaces (4 space supremacy).
    # - 's/"/\\"/g'       escapses all double quotations.
    # - 's/$/\\n/'        appends a literal newline character (\n) to the end of the line.
    # - 's/.*/"&"/'       wraps the entire line in quotations. The & is \0.
    # - '$!s/.*/&,/'      appends a comma (,) to the end of all lines EXCLUDING the LAST line.
    sed -e 's/\t/     /g' -e 's/"/\\"/g' -e 's/$/\\n/' -e 's/.*/"&"/' -e '$!s/.*/&,/' $PY_FILE > $TMP_FILE

    # Note: sed can use (almost) anything as a delimiter, which makes some sed code fucking
    # unreadable. Here, the first set of delimiters is '/', and the second set of delimiters is '|'.
    #
    # Replace the placeholder 'FILE-NAME-HERE' with the python file name. The -i flag means we do
    # this replacement in place.
    sed -i "0,/FILE-NAME-HERE/s|FILE-NAME-HERE|\"# $PY_FILE_NAME\"|" "$TARGET_FILE"

    # LORE: This command singlehandedly made me age by about 20 years. sed wouldn't work since the
    # python file is too complex; i.e. it would read in the file as raw text, so it would
    # occasionally try to parse the input as a sed command. Then I tried using awk, but the syntax
    # was pretty horrendus. I finally landed on perl because apparently this is what perl is good
    # at, and I cannot lie, it is indeed pretty good at it.
    #
    # Replace the placeholder 'PYTHON-CODE-HERE' with the contents of the python file.
    perl -i -pe 'BEGIN{undef $/; $content = `cat '$TMP_FILE'`} s/PYTHON-CODE-HERE/$content/e if $. == 1' "$TARGET_FILE"

    # Sanity check (not really lol. We echo the name whether or not it worked.).
    echo "added $PY_FILE_NAME"
done

# TODO: I want to add the nbconvert command here, but I don't really know how you set up the
# container, so I guess we can figure it out together. For now, I'm just running it through a simple
# JSON validator in python.
python -mjson.tool $TARGET_FILE > /dev/null
if [ $? -ne 0 ]; then
    echo "Failed to create PDF. Cleaning up and exiting..."
    rm $TARGET_FILE
    exit 1
fi

echo "Successfully created $TARGET_NAME.pdf. It can be found here:"
echo "$TARGET_FILE"

exit 0
